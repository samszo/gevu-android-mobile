<?xml version="1.0" encoding="utf-8"?>
<tr:Tree xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:tr="com.sparkTree.*"
		 xmlns:mx="library://ns.adobe.com/flex/halo"
		 xmlns:sqlite="com.peterelst.air.sqlite.*"
		 width="100%" height="100%" itemIdentifyField="@idLieu" allowItemDisSelection="false"
		 useVirtualLayout="false" dragEnabled="false" dropEnabled="false" labelField="@label"
		 click="tree_clickHandler(event)"
		 creationComplete="init()"
		 >
	
	<fx:Declarations>
	<s:XMLListCollection id="TreeData">
		</s:XMLListCollection>
		<fx:XMLList id="xmlist">
			<node label="univers" idLieu="1" lieu_parent="-1"/>
		</fx:XMLList>
		
		<sqlite:SQLite id="db" file="gevu_mobile.db"/>
		<sqlite:Query id="tree_query" connection="{db.connection}" 
					  sql="SELECT node.niv,node.lib, node.id_lieu, node.lieu_parent,node.lft,node.rgt
					  FROM gevu_lieux AS node,
					  gevu_lieux AS parent
					  WHERE node.lft BETWEEN parent.lft AND parent.rgt
					  GROUP BY node.id_lieu
					  ORDER BY node.lft"
					  result="onSelectResult()" 
					  error="query_errorHandler(event)"
					  />
		
		
		<sqlite:Query id="form_query" connection="{db.connection}"
					  sql="{this.verifIsControleQuery + this.selected_id} 
					  GROUP BY l.id_lieu
					  ORDER BY l.id_lieu ;" 
					  result="form_query_resultHandler(event)"
					  error="query_errorHandler(event)"/>
		
		<sqlite:Query id="geo_query" connection="{db.connection}"
					  sql="SELECT id_geo,lat,lng,adresse
					  FROM gevu_geos where id_lieu={this.selected_id}"
					  result="geo_query_resultHandler(event)"
					  error="query_errorHandler(event)"/>
		
		<sqlite:Query id="add_geo" connection="{db.connection}"
					  sql="insert into gevu_geos 
					  (id_instant,id_lieu,lat,lng,zoom_min,zoom_max,adresse,kml,type_carte,id_donnee,maj)
					  values (0,{this.last_id},
					  {this.lat},
					  {this.lng},
					  0,0,'','','hybird',0,strftime('%J','{this.toSqlDate(myDate)}'))"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>		
		
		<sqlite:Query id="updateGeo" connection="{db.connection}"
					  sql="update gevu_geos set lat={this.lat},
					  lng={this.lng}
					  where id_lieu={this.selected_id}"
					  error="query_errorHandler(event)"
					  result="updateGeo_resultHandler(event)"/>
					  
					  
		<sqlite:Query id="get_lieu_info_add" connection="{db.connection}"
					  sql="select * from gevu_lieux where id_lieu={this.selected_id}"
					  result="get_lieu_info_add_resultHandler(event)"/>
		
		<sqlite:Query id="update_lib" connection="{db.connection}"
					  sql="update gevu_lieux set lib ='{this.nom_lieu}'
					  where id_lieu={this.selected_id}"
					  error="query_errorHandler(event)"
					  result="update_lib_resultHandler(event)"/>
		
		<sqlite:Query id="get_lieu_info_delete" connection="{db.connection}"
					  sql="select * from gevu_lieux where id_lieu={this.selected_id}"
					  result="get_lieu_info_delete_resultHandler(event)"/>
		
		
	                        <!-- THE PARENT HAS CHILDS-->	
		<sqlite:Query id="update_rgt_has_child" connection="{db.connection}"
					  sql="update gevu_lieux set rgt = rgt + 2 WHERE rgt > {this.selected_rgt}"  
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		<sqlite:Query id="update_lft_has_child" connection="{db.connection}"
					  sql="update gevu_lieux SET lft = lft + 2 WHERE lft > {this.selected_rgt}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		<sqlite:Query id="insert_has_child" connection="{db.connection}" 
					  sql="insert into gevu_lieux (id_rubrique,lib,id_parent,id_instant,lft,rgt,niv,maj,lieu_parent)
					       values(0,'{this.new_nom_lieu}',0,0,
					             {this.selected_rgt + 1},
					             {this.selected_rgt + 2},
					             {this.selected_niv + 1},
					  strftime('%J','{this.toSqlDate(myDate)}'),
					             {this.selected_id})" 
					  error="query_errorHandler(event)"
					  result="insert_lieu_resultHandler(event)"/>
			<!-- ************************************************************* -->
					  
					  
		
		                     <!-- THE PARENT Does not have CHILDS-->	
		<sqlite:Query id="update_rgt_no_child" connection="{db.connection}"
					  sql="update gevu_lieux set rgt = rgt + 2 WHERE rgt > {this.selected_lft}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		<sqlite:Query id="update_lft_no_child" connection="{db.connection}"
					  sql="update gevu_lieux SET lft = lft + 2 WHERE lft > {this.selected_lft}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		<sqlite:Query id="insert_no_child" connection="{db.connection}" 
					  sql="insert into gevu_lieux (id_rubrique,lib,id_parent,id_instant,lft,rgt,niv,maj,lieu_parent)
					  values(0,'{this.new_nom_lieu}',0,0,
					  {this.selected_lft + 1},
					  {this.selected_lft + 2},
					  {this.selected_niv + 1},
					  strftime('%J','{this.toSqlDate(myDate)}'),
					  {this.selected_id})" 
					  error="query_errorHandler(event)"
					  result="insert_lieu_resultHandler(event)"/>
		<!-- ********************************************************* -->
		
		<sqlite:Query id="last_inserted_id" connection="{db.connection}"
					  sql="select max(id_lieu) as max from gevu_lieux"
					  result="last_inserted_id_resultHandler(event)"
					  error="query_errorHandler(event)"/>
		
		<sqlite:Query id="deleting" connection="{db.connection}"
					  sql="DELETE FROM gevu_lieux WHERE lft BETWEEN {this.selected_lft} AND {this.selected_rgt}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		<sqlite:Query id="deleting_update_1" connection="{db.connection}"
					  sql="UPDATE gevu_lieux SET rgt={this.selected_lft - 1} WHERE rgt > {this.selected_rgt}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		
		<sqlite:Query id="deleting_update_2" connection="{db.connection}"
					  sql="UPDATE gevu_lieux SET lft={this.selected_rgt + 1} WHERE lft > {this.selected_rgt}"
					  error="query_errorHandler(event)"
					  result="insert_update_resultHandler(event)"/>
		
		
		<!-- ********************************************************* -->
		
		<sqlite:Query id="GetScenarioParam" connection="{db.connection}"
					  sql="SELECT params FROM gevu_scenario WHERE id_scenario=10"
					  result="GetScenarioParam_resultHandler(event)"
					  error="query_errorHandler(event)"/>
		
		<s:ArrayCollection id="testData" />
		
		<fx:XML id="xmlScene" source="idCritSE.xml"/>
			
	</fx:Declarations>
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			import com.sparkTree.TreeDataProvider;
			import com.sparkTree.TreeEvent;
			import com.sparkTree.TreeItem;
			import com.sparkTree.TreeItemCollection;
			import com.sparkTree.XMLList1;
			
			import flash.display.DisplayObject;
			import flash.net.dns.SRVRecord;
			import flash.sampler.NewObjectSample;
			import flash.sensors.Geolocation;
			import flash.utils.getDefinitionByName;
			
			import flashx.textLayout.formats.Float;
			
			import memorphic.xpath.XPathQuery;
			
			import mx.collections.IList;
			import mx.core.FlexGlobals;
			import mx.core.IVisualElement;
			import mx.events.CollectionEvent;
			import mx.events.FlexEvent;
			import mx.states.State;
			import mx.utils.ObjectUtil;
			
			import spark.components.Application;
			import spark.components.Button;
			import spark.components.View;
			import spark.events.IndexChangeEvent;
			import spark.events.ListEvent;
			
			import views.*; 
			
			gevu_antennes;
			gevu_batiments;
			gevu_espacesxexterieurs;
			gevu_espacesxinterieurs;
			gevu_groupes;
			gevu_locaux;
			gevu_logements;
			gevu_niveaux;
			gevu_objetsxexterieurs;
			gevu_objetsxinterieurs;
			gevu_parcelles;
			gevu_partiescommunes;
			
			[Bindable] private var selected_id:int;
			[Bindable] private var selected_lft:int;
			[Bindable] private var selected_rgt:int;
			[Bindable] private var selected_niv:int;
			[Bindable] private var lieu_info:Array=new Array;
			[Bindable] private var nom_lieu:String;
			[Bindable] public var new_nom_lieu: String; 
			[Bindable] private var myDate:Date = new Date();
			[Bindable] public var geo_adresse:String;
			[Bindable] public var geo_lat:Number ;
			[Bindable] public var geo_lng:Number;
			[Bindable] private var lat:Number =0.0;
			[Bindable] private var lng:Number =0.0;
			[Bindable] private var verifIsControleQuery: String =
					  "SELECT l.lib, l.id_lieu, a.id_antenne, b.id_batiment,c.id_geo,d.id_diag,e.id_doc,"+
					  "f.id_espace,g.id_espace_ext,h.id_espace_int,i.id_etablissement,j.id_niveau,"+
					  "k.id_objet_ext,m.id_objet_int,n.id_objet_voirie,o.id_observations,"+
					  "p.id_parcelle,q.id_probleme,s.id_groupe,t.id_logement,u.id_local,v.id_part_commu "+
					  "FROM gevu_lieux AS l "+
					  "LEFT JOIN gevu_antennes AS a ON a.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_batiments AS b ON b.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_geos AS c ON c.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_diagnostics AS d ON d.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_docsxlieux AS e ON e.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_espaces AS f ON f.id_lieu = l.id_lieu "+
					  "LEFT JOIN gevu_espacesxexterieurs AS g ON g.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_espacesxinterieurs AS h ON h.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_etablissements AS i ON i.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_niveaux AS j ON j.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_objetsxexterieurs AS k ON k.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_objetsxinterieurs AS m ON m.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_objetsxvoiries AS n ON n.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_observations AS o ON o.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_parcelles AS p ON p.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_problemes AS q ON q.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_groupes AS s ON s.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_logements AS t ON t.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_locaux AS u ON u.id_lieu = l.id_lieu "+
					  "LEFT JOIN Gevu_partiescommunes AS v ON v.id_lieu = l.id_lieu "+
					  "where l.id_lieu =";
			
			private var arrScenar:Array;
			private var params:Array;
			public var treeItem:TreeItem;
			private var finished:Boolean=false;
			private var fetchingChildNode:TreeItem;			
			private var dbFile:File;
			private var sqlConn:SQLConnection;
			private var sqlState:SQLStatement;
			
			[Bindable] private var last_id:int;
			
			private function init():void {
				init_tree();
				get_new_geo();
				GetScenarioParam.execute();
			}
			
			private function testXpath():void{
				var myQuery:XPathQuery = new XPathQuery("/node/node/node/node");
				var result:XMLList =myQuery.exec(xmlScene);
				trace (result);
			}
			
			public function getLat():Number{
				return this.lat;
			}
			
			public function getLng():Number{
				return this.lng;
			}
			
			public function setLat(lat:Number):void{
			 this.lat=lat;	
			}
			
			public function setLng(lng:Number):void{
				this.lng=lng;	
			}
			
			public function getID():int{
				return this.selected_id;
			}
			public function lpad(original:Object, length:int, pad:String):String
			{
				var padded:String = original == null ? "" : original.toString();
				while (padded.length < length) padded = pad + padded;
				return padded;
			}
			
			public function toSqlDate(dateVal:Date):String
			{
				return dateVal == null ? null : dateVal.fullYear
					+ "-" + lpad(dateVal.month + 1,2,'0')  // month is zero-based
					+ "-" + lpad(dateVal.date,2,'0')
					+ " " + lpad(dateVal.hours,2,'0')
					+ ":" + lpad(dateVal.minutes,2,'0')
					+ ":" + lpad(dateVal.seconds,2,'0')
					;
			}
			
			public function get_lib():String{
				return this.nom_lieu;
			}
			
			public function set_lib(lib:String):void{
				this.nom_lieu=lib;
			}
			
			public function init_tree():void{
				TreeData = new XMLListCollection(xmlist);
                this.dataProvider=TreeData;
				this.tree_query.execute();
			}
			
			
			private function verifIsControle(id:String,obj:String,id_lieu:String):Array {
			 var temp:Array;
		
			 sqlState.text=
			 "SELECT " + id +
				 " FROM gevu_lieux AS l "+
				 "LEFT JOIN "+ obj + " AS a ON a.id_lieu = l.id_lieu where l.id_lieu ="+ id_lieu ;
			 sqlState.addEventListener(SQLErrorEvent.ERROR,query_errorHandler);
             sqlState.execute();
			 temp=sqlState.getResult().data;
			 
			 return temp;
			 
			}
			
			
			private function findByIdTypeControle(id_type_controle:int):Array {
			  var temp:Array;	
			  sqlState.text="SELECT zend_obj FROM `gevu_typesxcontroles` WHERE id_type_controle="+id_type_controle;
			  sqlState.addEventListener(SQLErrorEvent.ERROR,query_errorHandler);
			  sqlState.execute();
			  temp=sqlState.getResult().data;	
			 return temp;
			}
			
		   private function getParentForTypeControle(obj:String,id_lieu:String):Array
			{
				var temp:Array;	
				sqlState.text=
				"select * from gevu_lieux as node, gevu_lieux as parent,"+ obj + 
				" as t " +
				"where  (node.lft BETWEEN parent.lft AND parent.rgt) "+
				"and (t.id_lieu = parent.id_lieu) "+
				"and (node.id_lieu="+id_lieu+")";
				sqlState.addEventListener(SQLErrorEvent.ERROR,query_errorHandler);
				sqlState.execute();
				temp=sqlState.getResult().data;
				return temp
			}
			//get control
			
			
		private function getIDtoVerifyTypeControle(x:String):String {
			var temp:String;
			 
			switch(x)
			{
				case "gevu_antennes":
				{
					temp="id_antenne";
					break;
				}
				
				
				case "gevu_groupes":
				{
					temp="id_groupe";
					break;
				}
					
				case "gevu_batiments":
				{
					temp="id_batiment";
					break;
				}
					
				case "gevu_parcelles":
				{
					temp="id_parcelle";
					break;
				}
					
				
				case "gevu_niveaux":
				{
					temp="id_niveau";
					break;
				}
				
				case "gevu_logements":
				{
					temp="id_logement";
					break;
				}
					
				case "gevu_locaux":
				{
					temp="id_local";
					break;
				}
					
				case "gevu_partiescommunes":
				{
					temp="id_part_commu";
					break;
				}
					
				case "gevu_objetsxexterieurs":
				{
					temp="id_objet_ext";
					break;
				}
					
				case "gevu_objetsxinterieurs":
				{
					temp="id_objet_int"
					break;
				}
					
				case "gevu_espacesxexterieurs":
				{
					temp="id_espace_ext";
					break;
				}
					
				case "gevu_espacesxinterieurs":
				{
					temp="id_espace_int";
					break;
				}
					
				case "gevu_objetsxvoiries":
				{
					temp="id_objet_voirie";
					break;
				}
				case "gevu_espaces":
				{
					temp="id_espace";
					break;
				}
				
			}
			return temp;
			}
				
				
				
		private function getLieuCtl(idLieu:int,idScenar:int=10):Array{
			var arrCtl:Array = new Array();
			var rTypeCtrl:Array = new Array();
			var items:Array = new Array();
			var rTypeCtrl1:Array = new Array();
			var items1:Array = new Array();
			var arrLieuxParents:Array = new Array();
			var etapes:Array= new Array();
			var rTC:Array=new Array();
			var arrLP:Array=new Array();
			var id_type_controle:int;
			var Path:String;
			var niv:int;
			var result:XMLList;
			var id:String;
			
			dbFile =File.applicationDirectory.resolvePath("gevu_mobile.db");
			sqlConn= new SQLConnection();
			sqlState = new SQLStatement();
			sqlConn.open(dbFile);
			sqlState.sqlConnection=sqlConn;
			
			//select * from gevu_lieux where id_lieu={this.selected_id}"
			
			sqlState.text="select * from gevu_lieux where id_lieu="+idLieu;
			sqlState.execute();
			var lieuInfo:Array=sqlState.getResult().data;
			this.selected_niv=lieuInfo[0].niv;
			//on boucle sur les scènes
			for (var i:int=0;i<this.params.length;i++)
			{	
				etapes=params[i].etapes;
				if(etapes!=null)
				{
				 //on boucle sur les étapes de la scène	
				 for(var k:int=0;k<etapes.length;k++) 
				 {
				  id_type_controle=etapes[k].id_type_controle;
				  //récupère les informations du contrôle
				  
				  rTypeCtrl= findByIdTypeControle(id_type_controle);
				  //sort s'il n'y a pas d'objet lié
				  if(rTypeCtrl[0].zend_obj==null) continue;
				  //vérifie si le lieu a le controle
				  id=getIDtoVerifyTypeControle(rTypeCtrl[0].zend_obj);  
				  items=verifIsControle(id,rTypeCtrl[0].zend_obj,idLieu.toString());
				  //ObjectUtil.getClassInfo(items[0]).properties[0]
				   
				  if(items[0][id]!=null) 
				  {
					  
					  sqlConn.close();
					  return arrCtl; 			  
				  }
				  //récupère le parent qui possède ce type de controle
				  arrLieuxParents=getParentForTypeControle(rTypeCtrl[0].zend_obj,idLieu.toString());
				  if(arrLieuxParents !=null)
				  { 
					//on récupère le détail de la scène
					//calcul le nombre de niveau entre le lieu et son parent
					  
				    niv=this.selected_niv - arrLieuxParents[0].niv ; 
					
					Path= "/node";
					//création de la requête Xpath
					for (var j:int=0;j<niv;j++) {
					 Path += "/node";	
					 //vérifie si un des parents a déjà le contrôle
					 var myQuery:XPathQuery = new XPathQuery(Path);
					 result=myQuery.exec(xmlScene);
						for (var m:int=0;m<result.length();m++)
						{
						  rTC=findByIdTypeControle(result[m].@idCtrl);
						   if(rTC[0].zend_obj!=null) 
						   {
							   arrLP=getParentForTypeControle(rTC[0].zend_obj,idLieu.toString());
							     if(arrLP)
								 {
								   //ajoute une condition dans la requête XML
								   Path += "[@idCtrl="+result[m].@idCtrl+"]";
								 }
						   }
						}//Xpath query result
					}//création de la requête Xpath
					var myQuery1:XPathQuery = new XPathQuery(Path);
					result=myQuery1.exec(xmlScene);
					  for (var t:int=0;t<result.length();t++) 
					  {
						  var jk:int =result[t].@idCtrl;
						  rTypeCtrl1=findByIdTypeControle(result[t].@idCtrl);
						  id=getIDtoVerifyTypeControle(rTypeCtrl1[0].zend_obj);  
						  items1=verifIsControle(id,rTypeCtrl1[0].zend_obj,idLieu.toString());
						  
						  //si le lieu à déjà le contrôle on ne peut pas en ajouter
						  if(items1[0][id]!=null) 
						    
						  {
						   sqlConn.close();
						   return new Array();
						  }
						  else {
							  arrCtl.push(rTypeCtrl1);
						  }
					  }//
				  }//arrLieuxParents
				  else {
					  //si on ne trouve aucun controle on peut ajouter le contrôle
					  var arrType:Array = new Array();
					  arrType=findByIdTypeControle(id_type_controle);
					  arrCtl.push(arrType);
				  }//
				}//on boucle sur les étapes de la scène
			  }//etapes !=null	 
			}//on boucle sur les scènes
			
			sqlConn.close(); 
			return arrCtl; 
			
		}//fin de methode
			
			
			
			/* 
			 * This function is responsible for
             * Building the tree			
             */	
			private function onSelectResult():void {
				var xml_nodes:XMLList;
				var x:XML;
				var nodes:ArrayCollection = new ArrayCollection(this.tree_query.data);
				var idnoeud:int;	
				for (var i:int=1;i<nodes.length;i++)
				{
				idnoeud=nodes.getItemAt(i).lieu_parent;	
				x=xmlist.descendants().(@idLieu==idnoeud)[0];
				if(x!=null)
					x.appendChild(<node label={nodes.getItemAt(i).lib} idLieu={nodes.getItemAt(i).id_lieu} lieu_parent={idnoeud}/>);
				else
					xmlist.appendChild(<node label={nodes.getItemAt(i).lib} idLieu={nodes.getItemAt(i).id_lieu} lieu_parent={idnoeud}/>);
				}
			
		   }
			
            
			protected function tree_clickHandler(event:MouseEvent):void
			{
			 this.treeItem= event.currentTarget.selectedItem as TreeItem;
			 this.selected_id=this.treeItem.source.@idLieu;
			 this.nom_lieu=this.treeItem.source.@label;
			 if(this.selected_id!=1) 
			 {
			 var cont:Array=getLieuCtl(this.selected_id,10);
			 var btns:Array = new Array();
			 var temp:Array;
			 var v:View = new View();
			 var numChild:int;
			  if (cont.length!=0)
			  {  
				  numChild=FlexGlobals.topLevelApplication.main_interface.numChildren 
				  if (numChild>0)
				  {
				  FlexGlobals.topLevelApplication.main_interface.removeAllElements();
			  }
				 for(var i:int=0;i<cont.length;i++)
				 {
				  btns[i] = new Button();
				  temp=cont[i];
				  btns[i].label=temp[0].zend_obj;
				  FlexGlobals.topLevelApplication.main_interface.addElement(btns[i]); 
				  }
				 FlexGlobals.topLevelApplication.nom_lieu.text=this.nom_lieu;
				 FlexGlobals.topLevelApplication.view2.selectedIndex=0;
				 FlexGlobals.topLevelApplication.previewPanel.visible=false;
				 
			  }
			  else {
				  form_query.execute();
				 
			  }
			  geo_query.execute();   
			 }
			 
			 
			 
			  
			 }
			
			protected function form_query_resultHandler(event:SQLEvent):void
			{
			 var form_res:ArrayCollection= new ArrayCollection(form_query.data);
			 var ids:Array = getForms(form_res);
			 var className:String;
			 var ClassReference:Class;
			 var instance:Object;
			 //these references are added for the compiler to 
			 // have a refernce and execute the getDefinitionByName()
			 //methode and if not, an : variable not found error will happen
			 
			 
			 //removing all interfaces
			  if (FlexGlobals.topLevelApplication.main_interface.numChildren>0)
					  FlexGlobals.topLevelApplication.main_interface.removeAllElements();
			  
			  for (var k:int=0;k<ids.length;k++)
			  {
				  
				 className= "views."+ids[k];
				 if(
					 className == 'views.gevu_antennes'  ||
					 className == 'views.gevu_batiments' ||
				     className == 'views.gevu_diagnostics' ||
					 className == 'views.gevu_docsxlieux' ||
					 className == 'views.gevu_espaces' ||
					 className == 'views.gevu_espacesxexterieurs' ||
					 className == 'views.gevu_espacesxinterieurs' ||
					 className == 'views.gevu_etablissements' ||
					 className == 'views.gevu_niveaux' ||
					 className == 'views.gevu_objetsxexterieurs' ||
					 className == 'views.gevu_objetsxinterieurs' ||
					 className == 'views.gevu_objetsxvoiries' ||
					 className == 'views.gevu_observations' ||
				     className == 'views.gevu_parcelles' ||
					 className == 'views.gevu_problemes' ||
					 className == 'views.gevu_groupes' ||
					 className == 'views.gevu_logements' ||
					 className == 'views.gevu_locaux' ||
				     className == 'views.gevu_partiescommunes')
				 {
				 ClassReference = getDefinitionByName(className) as Class;
				 instance = new ClassReference();
				 instance.set_selected_id(selected_id);
				 FlexGlobals.topLevelApplication.main_interface.addElement(instance);
				 }
			  }
			}//function
			
			
			
			public function getForms(info:ArrayCollection):Array{
				var compo:Array = new Array;
				var i:int=0 ;
				
				//there is a way to change this.
				if (info.getItemAt(0).id_antenne !=null) {
					compo[i] = "gevu_antennes";
					i++;
				}
				
				if (info.getItemAt(0).id_batiment !=null) {
					compo[i] = "gevu_batiments";
					i++;
				}
				
				if (info.getItemAt(0).id_diag !=null) {
					compo[i] = "gevu_diagnostics";
					i++;
				}
				
				if (info.getItemAt(0).id_doc !=null) {
					compo[i] = "gevu_docsxlieux";
					i++;
				}
				
				if (info.getItemAt(0).id_espace !=null) {
					compo[i] = "gevu_espaces";
					i++;
				}
				
				if (info.getItemAt(0).id_espace_ext !=null) {
					compo[i] = "gevu_espacesxexterieurs";
					i++;
				}
				
				if (info.getItemAt(0).id_espace_int !=null) {
					compo[i] = "gevu_espacesxinterieurs";
					i++;
				}
				
				if (info.getItemAt(0).id_etablissement !=null) {
					compo[i] = "gevu_etablissements";
					i++;
				}
				
				
				if (info.getItemAt(0).id_niveau !=null) {
					compo[i] = "gevu_niveaux";
					i++;
				}
				
				if (info.getItemAt(0).id_objet_ext !=null) {
					compo[i] = "gevu_objetsxexterieurs";
					i++;
				}
				
				if (info.getItemAt(0).id_objet_int !=null) {
					compo[i] = "gevu_objetsxinterieurs";
					i++;
				}
				
				if (info.getItemAt(0).id_objet_voirie !=null) {
					compo[i] = "gevu_objetsxvoiries";
					i++;
				}
				
				if (info.getItemAt(0).id_observations !=null) {
					compo[i] = "gevu_observations";
					i++;
				}
				
				if (info.getItemAt(0).id_parcelle !=null) {
					compo[i] = "gevu_parcelles";
					i++;
				}
				
				if (info.getItemAt(0).id_probleme !=null) {
					compo[i] = "gevu_problemes";
					i++;
				}
				
				if (info.getItemAt(0).id_groupe !=null) {
					compo[i] = "gevu_groupes";
					i++;
				}
				
				if (info.getItemAt(0).id_logement !=null) {
					compo[i] = "gevu_logements";
					i++;
				}
				
				if (info.getItemAt(0).id_local !=null) {
					compo[i] = "gevu_locaux";
					i++;
				}
				
				if (info.getItemAt(0).id_part_commu !=null) {
					compo[i] = "gevu_partiescommunes";
					i++;
				}
				return compo;
			}
			
			
			
			public function add_lieu():void{
				dbFile =File.applicationDirectory.resolvePath("gevu_mobile.db");
				sqlConn= new SQLConnection();
				sqlState = new SQLStatement();
				sqlConn.open(dbFile);
				sqlState.sqlConnection=sqlConn;
				var temp:Array;
			    var maxrgt:int;
				if (this.selected_rgt != this.selected_lft +1)
				{	
				sqlState.text= "SELECT max(node.rgt)-1 as maxrgt " +
				" FROM gevu_lieux AS node, gevu_lieux AS parent " +
				" WHERE (node.lft BETWEEN parent.lft AND parent.rgt) " +
				" AND parent.id_lieu="+ this.selected_id;
				sqlState.execute();
				temp=sqlState.getResult().data;
				maxrgt=temp[0].maxrgt;
				
				//update
				sqlState.text="update gevu_lieux set rgt = rgt + 2 WHERE rgt >"+ maxrgt;
				sqlState.execute();
				sqlState.text="update gevu_lieux SET lft = lft + 2 WHERE lft >"+maxrgt;
				sqlState.execute();
				
				//insert
				sqlState.text=
			    "insert into gevu_lieux (id_rubrique,lib,id_parent,id_instant,lft,rgt,niv,maj,lieu_parent) "+ 
				"values(0,'" + this.new_nom_lieu + "',0,0," +
			    (maxrgt + 1) + "," +
			    (maxrgt + 2) + "," +
				(this.selected_niv + 1) + "," +
				"strftime('%J','"+this.toSqlDate(myDate)+"') , " +
				this.selected_id + ")";
				this.sqlState.addEventListener(SQLEvent.RESULT,insert_lieu_resultHandler);
				this.sqlState.execute();
				}//parent
					
				else
				{
					
					this.update_lft_no_child.execute();
					this.update_rgt_no_child.execute();
					this.insert_no_child.execute();
					
				}//not parent
				
			}
			
			
			protected function get_lieu_info_add_resultHandler(event:SQLEvent):void
			{
				this.lieu_info=this.get_lieu_info_add.data;
				this.selected_lft=lieu_info[0].lft;
				this.selected_rgt=lieu_info[0].rgt;
				this.selected_niv=lieu_info[0].niv;
				this.add_lieu();
				
			}
			
			protected function get_lieu_info_delete_resultHandler(event:SQLEvent):void
			{
				this.lieu_info=this.get_lieu_info_delete.data;
				this.selected_lft=lieu_info[0].lft;
				this.selected_rgt=lieu_info[0].rgt;
				this.selected_niv=lieu_info[0].niv;
				this.delete_lieu();
				
			}
			
			protected function query_errorHandler(event:SQLErrorEvent):void
			{
				var o:Object=event;
			}
			
			protected function insert_update_resultHandler(event:SQLEvent):void
			{
			var o:Object=event;
			}
			
			protected function update_lib_resultHandler(event:SQLEvent):void
			{
				this.tree_query.execute();
				FlexGlobals.topLevelApplication.viewstack.selectedIndex = 0;
			}
			
			
			
			protected function geo_query_resultHandler(event:SQLEvent):void
			{
				var geo_data:Array=this.geo_query.data;
				var ClassReference:Class;
				var instance:Object;
				gevu_geos;
				this.geo_adresse=geo_data[0].adresse;
				this.geo_lat=geo_data[0].lat;
				this.geo_lng=geo_data[0].lng;
				 if (FlexGlobals.topLevelApplication.arbre.numChildren==1)
					 FlexGlobals.topLevelApplication.arbre.removeElementAt(0);
				 
				ClassReference = getDefinitionByName("views.gevu_geos") as Class;
				instance = new ClassReference();
				instance.adresse=this.geo_adresse;
				instance.lat=this.geo_lat
				instance.lng=this.geo_lng;
				FlexGlobals.topLevelApplication.arbre.addElement(instance);
				}
			
			public function get_new_geo():void {
				var geo:Geolocation;
				if(Geolocation.isSupported){
				  geo = new Geolocation();
				  geo.setRequestedUpdateInterval(100);
				  geo.addEventListener(StatusEvent.STATUS,onStatus);
				  geo.addEventListener(GeolocationEvent.UPDATE,onUpdateGeo);
				 }
				else {
					trace("Geo Not supported")
				}
				
			}

			private function onUpdateGeo(event:GeolocationEvent):void{
			 this.lat=event.latitude;
			 this.lng=event.longitude;
			}
			
			private function onStatus(event:StatusEvent):void {
			trace(event.code);	
			}
			
			protected function insert_lieu_resultHandler(event:SQLEvent):void
			{
				this.get_new_geo();
			    this.last_inserted_id.execute();	
			}
			
			
			public function delete_lieu():void{
				
				var node:TreeItem = this.treeItem;
				node.branch.removeItem(node);
				this.deleting.execute();
				this.deleting_update_1.execute();
				this.deleting_update_2.execute();
				
			}
			
			public function edit():void{
				var temp:TreeItem;
				temp=this.treeItem;
				temp.source.@label=this.nom_lieu;
				this.update_lib.execute();
			}
			
			
			protected function last_inserted_id_resultHandler(event:SQLEvent):void
			{
				var data_id:Array= this.last_inserted_id.data; 
				var temp :XML;
				var x:XML; 
				this.last_id=data_id[0].max;
				this.add_geo.execute();
				x = <node label={this.new_nom_lieu} idLieu={this.last_id} lieu_parent={this.selected_id}/>;
				temp = this.dataProvider.getItemAt(0).source.descendants().(@idLieu == this.selected_id)[0];
				if(this.treeItem.hasChildren()==true)
				{	
					var node:TreeItem= new TreeItem(this.treeItem.collection,this.treeItem,x,this.last_id);
					node.branch.addItem(node);
				}
				if(temp!=null){
				temp.appendChild(x);
				}
				this.expandItem(this.treeItem);
				FlexGlobals.topLevelApplication.viewstack.selectedIndex = 0;
				 	
			}
			
			protected function updateGeo_resultHandler(event:SQLEvent):void
			{
				var o:Object=event;
				this.geo_query.execute();
				
			}
			
			protected function GetScenarioParam_resultHandler(event:SQLEvent):void
			{
			 arrScenar = this.GetScenarioParam.data;
			 params= JSON.decode(arrScenar[0].params) as Array;
			 
			}
			
		]]>	
	</fx:Script>
</tr:Tree>
